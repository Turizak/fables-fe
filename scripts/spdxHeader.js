import fs from 'node:fs';
import path from 'node:path';
import { Octokit } from '@octokit/rest';

// Configuration
const CONFIG = {
  targetDirectories: ['/home/runner/work/fables-fe/fables-fe/components', '/home/runner/work/fables-fe/fables-fe/utils', '/home/runner/work/fables-fe/fables-fe/pages', '/home/runner/work/fables-fe/fables-fe/stores'],
  spdxHeader: '// SPDX-License-Identifier: Apache-2.0\n',
  allowedExtensions: ['.vue', '.ts'],
  isDryRun: process.argv.includes('--dry-run'),
  github: {
    token: process.env.GITHUB_TOKEN,
    repository: process.env.GITHUB_REPOSITORY,
    ref: process.env.GITHUB_REF,
  }
};

const octokit = new Octokit({
  auth: CONFIG.github.token
});

// Function to ensure fork exists
async function ensureForkExists(owner, repo) {
  try {
    // Check if fork already exists
    await octokit.repos.get({
      owner: 'spdx-license-bot', // Your bot account name
      repo: repo
    });
    console.log('Fork already exists');
    return;
  } catch (error) {
    if (error.status === 404) {
      // Create fork if it doesn't exist
      console.log('Creating new fork...');
      await octokit.repos.createFork({
        owner,
        repo,
      });
      
      // Wait for fork to be created (GitHub does this asynchronously)
      await new Promise(resolve => setTimeout(resolve, 5000));
    } else {
      throw error;
    }
  }
}

// Function to create a new branch in the fork
async function createBranchInFork(owner, repo, baseSha) {
  const branchName = `feature/add-spdx-headers-${Date.now()}`;
  
  await octokit.git.createRef({
    owner: 'spdx-license-bot', // Your bot account name
    repo,
    ref: `refs/heads/${branchName}`,
    sha: baseSha
  });
  
  return branchName;
}

// Function to commit changes to fork
async function commitChangesToFork(repo, branchName, modifiedFiles) {
  // Get the current commit SHA from the fork
  const { data: ref } = await octokit.git.getRef({
    owner: 'spdx-license-bot', // Your bot account name
    repo,
    ref: `heads/${branchName}`
  });

  // Create a new tree with the modified files
  const tree = [];
  for (const filePath of modifiedFiles) {
    const content = fs.readFileSync(filePath, 'utf8');
    const relativePath = filePath.replace(`/home/runner/work/${repo}/${repo}/`, '');
    
    tree.push({
      path: relativePath,
      mode: '100644',
      type: 'blob',
      content
    });
  }

  const { data: newTree } = await octokit.git.createTree({
    owner: 'spdx-license-bot', // Your bot account name
    repo,
    base_tree: ref.object.sha,
    tree
  });

  // Create a new commit
  const { data: newCommit } = await octokit.git.createCommit({
    owner: 'spdx-license-bot', // Your bot account name
    repo,
    message: 'Add SPDX license headers',
    tree: newTree.sha,
    parents: [ref.object.sha]
  });

  // Update the branch reference
  await octokit.git.updateRef({
    owner: 'spdx-license-bot', // Your bot account name
    repo,
    ref: `heads/${branchName}`,
    sha: newCommit.sha
  });
}

// Function to create pull request from fork
async function createPullRequestFromFork(owner, repo, branchName, modifiedFiles) {
  const prBody = `
Added SPDX License Headers

This PR adds Apache 2.0 SPDX license headers to ${modifiedFiles} files.

Modified directories:
${CONFIG.targetDirectories.map(dir => `- ${dir}`).join('\n')}

File types processed:
${CONFIG.allowedExtensions.join(', ')}

_This PR was automatically generated by the SPDX License Header Tool_
`;

  const pr = await octokit.pulls.create({
    owner,
    repo,
    title: 'Add SPDX License Headers',
    head: `spdx-license-bot:${branchName}`,
    base: 'main',
    body: prBody
  });

  return pr.data.html_url;
}

// Your existing helper functions remain the same
function validateDirectories(directories) {
  directories.forEach((directory) => {
    try {
      const stats = fs.statSync(directory);
      if (!stats.isDirectory()) {
        throw new Error(`${directory} is not a directory`);
      }
    } catch (error) {
      if (error.code === 'ENOENT') {
        throw new Error(`Directory ${directory} does not exist`);
      }
      throw error;
    }
  });
}

function shouldProcessFile(fileName) {
  return CONFIG.allowedExtensions.includes(path.extname(fileName));
}

function addHeaderToFile(filePath) {
  try {
    const fileContent = fs.readFileSync(filePath, 'utf8');

    if (fileContent.includes('SPDX-License-Identifier: Apache-2.0')) {
      console.log(`[SKIP] Header already exists in ${filePath}`);
      return { skipped: true, wouldModify: false };
    }

    const updatedContent = CONFIG.spdxHeader + fileContent;

    if (CONFIG.isDryRun) {
      console.log(`[DRY RUN] Would add header to ${filePath}`);
      return { skipped: false, wouldModify: true };
    }

    fs.writeFileSync(filePath, updatedContent, 'utf8');
    console.log(`[ADDED] Header added to ${filePath}`);
    return { skipped: false, wouldModify: true };
  } catch (error) {
    console.error(`Error processing file ${filePath}:`, error.message);
    throw error;
  }
}

function addHeaderToFiles(directory) {
  try {
    const entries = fs.readdirSync(directory, { withFileTypes: true });
    let modifiedFiles = 0;
    let skippedFiles = 0;

    entries.forEach((entry) => {
      const fullPath = path.join(directory, entry.name);
      try {
        if (entry.isDirectory()) {
          const { modified, skipped } = addHeaderToFiles(fullPath);
          modifiedFiles += modified;
          skippedFiles += skipped;
        } else if (entry.isFile() && shouldProcessFile(entry.name)) {
          const result = addHeaderToFile(fullPath);
          if (result.wouldModify) modifiedFiles++;
          if (result.skipped) skippedFiles++;
        }
      } catch (error) {
        console.error(`Error processing ${fullPath}:`, error.message);
      }
    });

    return { modified: modifiedFiles, skipped: skippedFiles };
  } catch (error) {
    console.error(`Error reading directory ${directory}:`, error.message);
    throw error;
  }
}

// Modified main execution
async function main() {
  try {
    console.log(`SPDX Header Addition Tool`);
    console.log(`Mode: ${CONFIG.isDryRun ? 'DRY RUN' : 'LIVE'}`);
    console.log(`Target Directories: ${CONFIG.targetDirectories.join(', ')}`);
    console.log(`File Types: ${CONFIG.allowedExtensions.join(', ')}`);
    console.log('----------------------------------------');

    validateDirectories(CONFIG.targetDirectories);

    // First pass: check if any files need modification
    let totalModified = 0;
    let totalSkipped = 0;
    
    for (const directory of CONFIG.targetDirectories) {
      console.log(`Scanning directory: ${directory}`);
      const { modified, skipped } = addHeaderToFiles(directory);
      totalModified += modified;
      totalSkipped += skipped;
    }

    if (totalModified === 0) {
      console.log('No files need modification. Exiting.');
      process.exit(0);
    }

    if (!CONFIG.isDryRun) {
      const [owner, repo] = CONFIG.github.repository.split('/');

      // Ensure fork exists
      await ensureForkExists(owner, repo);
      console.log('Fork is ready');

      // Get the current commit SHA from the main repo
      const { data: ref } = await octokit.git.getRef({
        owner,
        repo,
        ref: 'heads/main'
      });

      // Create a new branch in the fork
      const branchName = await createBranchInFork(owner, repo, ref.object.sha);
      console.log(`Created branch in fork: ${branchName}`);

      // Second pass: modify files and track which ones changed
      const modifiedFilePaths = [];
      for (const directory of CONFIG.targetDirectories) {
        const entries = fs.readdirSync(directory, { withFileTypes: true });
        entries.forEach(entry => {
          const fullPath = path.join(directory, entry.name);
          if (entry.isFile() && shouldProcessFile(entry.name)) {
            const result = addHeaderToFile(fullPath);
            if (!result.skipped) {
              modifiedFilePaths.push(fullPath);
            }
          }
        });
      }

      // Commit changes to fork
      await commitChangesToFork(repo, branchName, modifiedFilePaths);
      console.log('Changes committed to fork');

      // Create pull request
      const prUrl = await createPullRequestFromFork(owner, repo, branchName, totalModified);
      console.log(`Pull request created: ${prUrl}`);
    }

    console.log('----------------------------------------');
    console.log('Summary:');
    console.log(`Files that would be modified: ${totalModified}`);
    console.log(`Files skipped (header exists): ${totalSkipped}`);

    if (CONFIG.isDryRun) {
      console.log('\nThis was a dry run. No files were modified.');
      console.log('To apply changes, run without --dry-run flag.');
    }

    process.exit(0);
  } catch (error) {
    console.error('Script failed:', error.message);
    process.exit(1);
  }
}

main();
